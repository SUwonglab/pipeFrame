#' @importFrom digest digest
#' @name Step-class
#' @rdname  Step-class
#' @title Methods for Step objects
#' @description
#' You can call Step objects operation methods below to
#' obtain information in objects.
#' @details
#' \code{Step} is a S4 class for generating Step S4 objects.
#' All Step objects generated by its subclasses.
#' To generate new Step objects, a function wrapper with fixed auguments needs to
#' be implemented. User uses these function to generate new Step functions
#' rather than use Step S4 class to generate object yourself.
#' @author Zheng Wei
#' @seealso

#' \code{\link{setGenome}}
#' \code{\link{setThread}}


#' @param .Object Step object scalar.
#' Step object return by process functions.
#' @param preProc \code{Logitcal} scalar.
#' show the available upstream processes if TRUE.(Default: FALSE)
#' @param nextProc \code{Logitcal} scalar.
#' show the available downstream processes if TRUE. (Default: TRUE)
#' @param curProc \code{Logitcal} scalar.
#' show the current process of parameter \code{.Object} if TRUE. (Default: TRUE)
#' @param display \code{Logitcal} scalar.
#' Save to pdf file if FALSE. (Default: TRUE)
#' @param item \code{Characters} scalar.
#' The items in parameter list or report list.
#' @param ... Additional arguments, currently unused.
#' @return the function and result of functions:
#'
#' @examples
#'

#' @export Step
Step <- setClass(Class = "Step",
         slots = list(
             argv = "list",
             paramList = "list",
             inputList = "list",
             outputList = "list",
             propList = "list",
             reportVal = "list",
             stepName = "character",
             finish = "logical",
             timeStampStart="POSIXct",
             timeStampEnd="POSIXct",
             maxThreads = "integer",
             id = "integer",
             defName = "character",
             loaded = "logical"
         ),
         prototype = c(argv = list(),
                       paramList = list(),
                       inputList = list(),
                       outputList = list(),
                       propList = list(),
                       reportVal = list(),
                       stepName = "Step",
                       finish = FALSE,
                       timeStampStart=Sys.time(),
                       timeStampEnd=Sys.time(),
                       maxThreads = 1L,
                       id = 0L,
                       defName = "Step",
                       loaded = FALSE)
         )
setMethod(f = "initialize",
          signature = "Step",
          definition = function(.Object,prevSteps = list(), defName = NULL, ...){



              argv <- c(as.list(environment()),list(...))





              stopifnot(is(prevSteps,"list"))
              if(length(prevSteps)>0){
                  objs<-unlist(prevSteps)
                  for(obj in objs){
                      stopifnot(inherits(obj,"Step"))
                  }
              }

              stepName <- as.character(class(.Object))

              .Object@stepName <- stepName
              if(is.null(defName)){
                  .Object@defName <- stepName
              }else{
                  .Object@defName <- defName
              }

              argvother <- argv[startsWith(names(argv),paste0(stepName, "."))]
              for(a in names(argvother)){
                  a0 <- substring(a,2 + nchar(.Object@defName))
                  if(sum(names(argv)==a0)>0){
                      argv[[a0]] <- argvother[[a]]
                  }else{
                      stop(paste0(a," is not parameter of Step ", stepName))
                  }
              }
              .Object@argv <- argv


              argSize <- length(prevSteps)

              if(argSize>0){
                  for(i in 1:argSize){
                      if(!is.null(prevSteps[[i]]) && !isReady(prevSteps[[i]])){
                          stop(paste(getStepName(prevSteps[[i]]),"is not ready"))
                      }
                      if(!checkRelation(getStepName(prevSteps[[i]]),getStepName(.Object),i)){
                          stop(paste(getStepName(prevSteps[[i]]),"is not valid input"))
                      }
                      .Object@propList <- c(.Object@propList, prevSteps[[i]]@propList)
                  }
              }
              nameIdList <- getOption("pipeFrameConfig.nameIdList")
              print(nameIdList)
              if(is.null(nameIdList)){
                  nameIdList <- list()
              }
              if(!is.null(nameIdList[[.Object@defName]])){
                  .Object@id <- nameIdList[[.Object@defName]]
              }else{
                  count <- getOption("pipeFrameConfig.count")
                  .Object@id <- count
                  options(pipeFrameConfig.count = count+1L)
                  nameIdList[[.Object@defName]] <- .Object@id
                  options(pipeFrameConfig.nameIdList = nameIdList)
              }
              options(pipeFrameConfig.allowChangeJobDir = FALSE)


              if(!dir.exists(getStepWorkDir(.Object))){
                  dir.create(getStepWorkDir(.Object))
              }

              argv <- c(list(.Object = .Object),argv)
              obj_return_from_init <- do.call(init,argv)
              stopifnot(is(obj_return_from_init,getStepName(.Object)))
              .Object <- obj_return_from_init
              paramValidation(.Object)
              obj_return_from_porcessing<-process(.Object)
              stopifnot(is(obj_return_from_porcessing,getStepName(.Object)))
              .Object <- obj_return_from_porcessing


              .Object
          })

#' @return \item{init}{(For package developer) An Step child class object with initialized input, output and other parameters}
#' @rdname Step-class
#' @aliases init
#' @export
setGeneric(name = "init",
           def = function(.Object,prevSteps = list(),...){
               standardGeneric("init")
           })



setGeneric(name = "process",
           def = function(.Object,...){
               standardGeneric("process")
           })


setMethod(f = "process",
          signature = "Step",
          definition = function(.Object,...){
              msgBoxBegin()
              if(checkMD5Cache(.Object)){
                  writeLog(.Object,paste0("The step:`",.Object@stepName,"` was finished. Nothing to do."))
                  writeLog(.Object,"If you need to redo, please call 'clearProcCache(YourObject)'")
                  load(getParamMD5Path(.Object))
                  .Object <- pipeFrameObj
                  .Object@loaded <- TRUE
              }else{
                  writeLog(.Object,as.character(Sys.time()))
                  writeLog(.Object,paste0("start processing data: ", .Object@stepName))
                  .Object@timeStampStart<-Sys.time()
                  .Object <- processing(.Object)
                  .Object@timeStampEnd<-Sys.time()
                  .Object@reportVal$timeStampStart <- .Object@timeStampStart
                  .Object@reportVal$timeStampEnd <- .Object@timeStampEnd
                  .Object <- setFinish(.Object)
                  pipeFrameObj <- .Object
                  save(pipeFrameObj, file = getParamMD5Path(.Object))
              }
              msgBoxDone()
              .Object
          })



setGeneric(name = "getStepName",
           def = function(.Object,...){
               standardGeneric("getStepName")
           })

#' @return \item{getStepName}{get Step object Characher name}
#' @rdname Step-class
#' @aliases getStepName
#' @export
setMethod(f = "getStepName",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@stepName)
          })




setGeneric(name = "getDefName",
           def = function(.Object,...){
               standardGeneric("getDefName")
           })

#' @return \item{getDefName}{get Step object Characher name}
#' @rdname Step-class
#' @aliases getDefName
#' @export
setMethod(f = "getDefName",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@defName)
          })

setGeneric(name = "getParam",
           def = function(.Object,item,...){
               standardGeneric("getParam")
           })

#' @rdname Step-class
#' @return \item{getParam}{Get parameter value set by process function.
#' See \code{getParamItems} to obtain valid item for query.}
#' @aliases  getParam
#' @export
setMethod(f = "getParam",
          signature = "Step",
          definition = function(.Object,item, type = c("input","output","other"),...){
              type <- unique(type)
              for(t in type){
                  t1 <- match.arg(t,c("input","output","other"))
                  if(t1 == "input"){
                      if(!is.null(.Object@inputList[[item]])){
                          return(.Object@inputList[[item]])
                      }
                  }else if(t1 == "output"){
                      if(!is.null(.Object@outputList[[item]])){
                          return(.Object@outputList[[item]])
                      }
                  }else{
                      if(!is.null(.Object@paramList[[item]])){
                          return(.Object@paramList[[item]])
                      }
                  }
              }
              return(NULL)
          })

setGeneric(name = "getParamItems",
           def = function(.Object, type = c("input","output","other"),...){
               standardGeneric("getParamItems")
           })

#' @rdname Step-class
#' @return \item{getParamItems}{Get parameter name list}
#' @aliases  getParamItems
#' @export
setMethod(f = "getParamItems",
          signature = "Step",
          definition = function(.Object, type = c("input","output","other"), ...){
              type <- unique(type)
              allitem <- c()
              for(t in type){
                  t1 <- match.arg(t,c("input","output","other"))
                  if(t1 == "input"){
                      allitem <- c(allitem,names(.Object@inputList))
                  }else if(t1 == "output"){
                      allitem <- c(allitem,names(.Object@outputList))
                  }else{
                      allitem <- c(allitem,names(.Object@paramList))
                  }
              }

              return(allitem)
          })



setGeneric(name = "isReady",
           def = function(.Object,...){
               standardGeneric("isReady")
           })

#' @rdname Step-class
#' @return \item{isReady}{Is the process ready for downstream process}
#' @aliases  isReady
#' @export
setMethod(f = "isReady",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@finish)
          })


setGeneric(name = "clearProcCache",
           def = function(.Object,...){
               standardGeneric("clearProcCache")
           })

#' @rdname Step-class
#' @return \item{clearProcCache}{Clear cache of Step object}
#' @aliases  clearProcCache
#' @export
setMethod(f = "clearProcCache",
          signature = "Step",
          definition = function(.Object,...){
              if(!unlink(getParamMD5Path(.Object))){
                  message("Chache has been cleared")
              }else{
                  message("Chache does not exist. Nothing has been done.")
              }
              outItems <-getParamItems(.Object,type="output")
              for(item in outItems){
                  unlink(normalizePath(unlist(getParam(item))),recursive = TRUE)
              }
              .Object@finish<-FALSE
              .Object
          })



setGeneric(name = "getReportVal",
           def = function(.Object,item,...){
               standardGeneric("getReportVal")
           })

#' @rdname Step-class
#' @return \item{getReportVal}{Get report value of item.
#' See \code{getReportItems} to obtain valid item for query.}
#' @aliases   getReportVal
#' @export
setMethod(f = "getReportVal",
          signature = "Step",
          definition = function(.Object,item,...){
              if(.Object@finish){
                  if(sum(item == getReportItemsImp(.Object))>0){
                      return(getReportValImp(.Object,item))
                  }else{
                      stop(paste0(item," is not an item of report value."))
                  }
              }else{
                  stop("Unfinished process is not available for report value.")
              }
          })


setGeneric(name = "getReportItems",
           def = function(.Object,...){
               standardGeneric("getReportItems")
           })

#' @rdname Step-class
#' @return \item{getReportItems}{Get all items that can be reported}
#' @aliases getReportItems
#' @export
setMethod(f = "getReportItems",
          signature = "Step",
          definition = function(.Object,...){
              if(.Object@finish){
                  return(getReportItemsImp(.Object))
              }else{
                  stop("Unfinished process is not available for report items.")
              }
          })
setGeneric(name = "getAutoPath",
           def = function(.Object,originPath,regexProcName,suffix,...){
               standardGeneric("getAutoPath")
           })

#' @return \item{getAutoPath}{(For package developer)Developer can use this method to generate new file name based on exist input file name}
#' @rdname Step-class
#' @aliases getAutoPath
#' @export
setMethod(f = "getAutoPath",
          signature = "Step",
          definition = function(.Object,originPath,regexProcName,suffix,...){
              stopifnot(is.character(originPath))
              prefix<-getBasenamePrefix(originPath,regexProcName)
              return(file.path(getStepWorkDir(.Object),paste0(prefix,".",suffix)))
          })
setGeneric(name = "paramValidation",
           def = function(.Object,...){
               standardGeneric("paramValidation")
           })
setMethod(f = "paramValidation",
          signature = "Step",
          definition = function(.Object,...){
              if(!checkMD5Cache(.Object)){
                  checkAllPath(.Object)
              }
              checkRequireParam(.Object);
          })

#' @return \item{checkRequireParam}{(For package developer) Check required inputs are filled.}
#' @rdname Step-class
#' @aliases checkRequireParam
#' @export
setGeneric(name = "checkRequireParam",
           def = function(.Object,...){
               standardGeneric("checkRequireParam")
           })


#' @return \item{checkRequireParam}{(For package developer) Check required inputs are filled.}
#' @rdname Step-class
#' @aliases checkRequireParam
#' @export
setGeneric(name = "checkAllPath",
           def = function(.Object,...){
               standardGeneric("checkAllPath")
           })

setMethod(f = "checkAllPath",
          signature = "Step",
          definition = function(.Object,...){
              items <- getParamItems(.Object, type="intput")
              for(items in items){

              }
          })

setGeneric(name = "getParamMD5Path",
           def = function(.Object,...){
               standardGeneric("getParamMD5Path")
           })
#' @return \item{getParamMD5Path}{The Step object storage directory}
#' @rdname Step-class
#' @aliases getParamMD5Path
#' @export
setMethod(f = "getParamMD5Path",
          signature = "Step",
          definition = function(.Object,...){
              paramstr <- c(getStepName(.Object))
              itNames <- getParamItems(.Object,type="other")
              for(n in sort(itNames)){
                  paramstr<-c(paramstr,n)
                  paramstr<-c(paramstr,getParam(.Object,n,type="other"))
              }
              ioNames <- getParamItems(.Object,type=c("input","output"))
              for(n in sort(ioNames)){
                  paramstr<-c(paramstr,n)
                  paths <- getParam(.Object,n,type = c("input","output"))
                  if(!is.character(paths) && !is.list(paths)){
                      paramstr <- c(paramstr,paths)
                      next
                  }
                  paths <- sort(unlist(paths))
                  paths1 <- c()
                  breakflag <- FALSE
                  for(path in paths){
                      if(dir.exists(path)){
                          paths1 <- c(paths1, sort(dir(path,recursive = TRUE)))
                      }else if(file.exists(path)){
                          paths1 <- c(paths1, path)
                      }else{
                          paramstr <- c(paramstr,runif(1))
                          breakflag <- TRUE
                          break;
                      }
                  }
                  if(breakflag){
                      break
                  }
                  paths <- paths1
                  paths <- paths[grep("pipeFrame.obj",paths,invert = TRUE)]
                  checkpaths <- c()
                  for(path in paths){
                      p <- normalizePath(path)
                      checkpaths <- c(checkpaths,p)
                      if(startsWith(p,getJobDir())){
                          p <- substring(p,2+nchar(getJobDir()))
                      }
                      paramstr <- c(paramstr,p)
                  }
              }
              flag = FALSE
              for(p in checkpaths){
                  filesize <- file.info(p)$size
                  paramstr <- c(paramstr,filesize)
              }
              md5code<-substr(digest(object = paramstr,algo = "md5"),1,8)
              md5filepath<-file.path(getStepWorkDir(.Object),paste("pipeFrame.obj",md5code,"RData",sep = "."))
              return(md5filepath)
          })
setGeneric(name = "setFinish",
           def = function(.Object,...){
               standardGeneric("setFinish")
           })
setMethod(f = "setFinish",
          signature = "Step",
          definition = function(.Object,...){
              .Object@finish<-TRUE
              writeLog(.Object,as.character(Sys.time()))
              writeLog(.Object,"processing finished")
              .Object
          })
setGeneric(name = "checkMD5Cache",
           def = function(.Object,...){
               standardGeneric("checkMD5Cache")
           })
setMethod(f = "checkMD5Cache",
          signature = "Step",
          definition = function(.Object,...){
              if(file.exists(getParamMD5Path(.Object))){
                  return(TRUE)
              }else{
                  return(FALSE)
              }
          })

setGeneric(name = "getStepWorkDir",
           def = function(.Object,...){
               standardGeneric("getStepWorkDir")
           })
#' @return \item{getStepWorkDir}{Get the step work directory of this object}
#' @rdname Step-class
#' @aliases getStepWorkDir
#' @export
setMethod(f = "getStepWorkDir",
          signature = "Step",
          definition = function(.Object,...){
              return(file.path(getJobDir(),paste0("Step_",sprintf("%02d",getStepId(.Object)),"_",getDefName(.Object))))
          })

setGeneric(name = "getStepId",
           def = function(.Object,...){
               standardGeneric("getStepId")
           })

#' @return \item{getStepId}{Get the step ID}
#' @rdname Step-class
#' @aliases getStepId
#' @export
setMethod(f = "getStepId",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@id)
          })



setGeneric(name = "writeLog",
           def = function(.Object,msg,...,isWarnning=FALSE,appendLog=TRUE,showMsg=TRUE){
               standardGeneric("writeLog")
           })
#' @return \item{writeLog}{(For package developer) write log.}
#' @rdname Step-class
#' @aliases writeLog
#' @export
setMethod(f = "writeLog",
          signature = "Step",
          definition = function(.Object,msg,...,isWarnning=FALSE,appendLog=TRUE,showMsg=TRUE){
              if(isWarnning){
                  warning(msg)
                  msg<-paste0("Warning:",msg)
              }else if(showMsg){
                  message(msg)
              }
              write.table(msg,file.path(getStepWorkDir(.Object),"pipeFrame.obj.log"),quote = FALSE,row.names = FALSE,col.names = FALSE,append = appendLog)
              .Object
          })

#' @return \item{processing}{(For package developer) Run pipeline step}
#' @rdname Step-class
#' @aliases processing
#' @export
setGeneric(name = "processing",
           def = function(.Object,...){
               standardGeneric("processing")
           })




#' @return \item{getReportValImp}{(For package developer) get Report Value}
#' @rdname Step-class
#' @aliases getReportValImp
#' @export
setGeneric(name = "getReportValImp",
           def = function(.Object,item,...){
               standardGeneric("getReportValImp")
           })


setMethod(f = "getReportValImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(.Object@reportVal[[item]])
          })

#' @return \item{getReportItemsImp}{(For package developer) getReportItemsImp}
#' @rdname Step-class
#' @aliases getReportItemsImp
#' @export
setGeneric(name = "getReportItemsImp",
           def = function(.Object,item,...){
               standardGeneric("getReportItemsImp")
           })


setMethod(f = "getReportItemsImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(names(.Object@reportVal))
          })




