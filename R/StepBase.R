#' @importFrom digest digest
#' @name Step-class
#' @rdname  Step-class
#' @title Methods for Step objects
#' @description
#' You can call Step objects operation methods below to
#' obtain information in objects.
#' @details
#' \code{Step} is a S4 class for generating Step S4 objects.
#' All Step objects generated by children classes inherit from Step.
#' To generate new Step objects, a function wrapper with fixed auguments needs to
#' be implemented. User uses these function to generate new Step functions
#' rather than use Step S4 class to generate object themselves
#' @author Zheng Wei
#' @seealso

#' \code{\link{setGenome}}
#' \code{\link{setThread}}


#' @param .Object \code{Step} object scalar.
#' Step object return by functions of each step functions.
#' @param type \code{Character} scalar.
#' Valid types of parameters including "input", "output" and "other"
#' @param item \code{Character} scalar.
#' The items in parameter list or report list.
#' @param originPath \code{Character} scalar.
#' The file name for output file is base on this origion path name.
#' @param regexSuffixName \code{Character} scalar. The suffix for replacement.
#' @param suffix \code{Character} scalar. The new suffix for the file.
#' @param msg \code{Character} scalar. The message to write into log file.
#' @param isWarnning \code{Logical} scalar. Set this message as warning message.
#' Defaut: FALSE
#' @param appendLog \code{Logical} scalar. Append to the log file. Defaut: TRUE
#' @param showMsg \code{Logical} scalar. Show the message on screen. Default: TRUE
#' @param filename \code{Character} scaler. The name of file under step working directiory
#' @param ... Additional arguments, currently unused.
#' @return the function and result of functions:
#'
#' @examples
#'
#'
#' library(BSgenome)
#' library(rtracklayer)
#'
#' # generate new Step : RandomRegionOnGenome
#' setClass(Class = "RandomRegionOnGenome",
#'          contains = "Step"
#' )
#'
#' setMethod(
#'     f = "init",
#'     signature = "RandomRegionOnGenome",
#'     definition = function(.Object,prevSteps = list(),...){
#'         # All arguments in function randomRegionOnGenome will be passed from "..."
#'         # so get the arguments from "..." first.
#'         allparam <- list(...)
#'         sampleNumb <- allparam[["sampleNumb"]]
#'         regionLen <- allparam[["regionLen"]]
#'         genome <- allparam[["genome"]]
#'         outputBed <- allparam[["outputBed"]]
#'         # no previous steps for this step so ingnore the "prevSteps"
#'         # begin to set input parameters
#'         # no input for this step
#'         # begin to set output parameters
#'         if(is.null(outputBed)){
#'             .Object@outputList$outputBed <-  getStepWorkDir(.Object,"random.bed")
#'         }else{
#'             .Object@outputList$outputBed <- outputBed
#'         }
#'         # begin to set other parameters
#'         .Object@paramList$regionLen <- regionLen
#'         .Object@paramList$sampleNumb <- sampleNumb
#'         if(is.null(genome)){
#'             .Object@paramList$bsgenome <- getBSgenome(getGenome())
#'         }else{
#'             .Object@paramList$bsgenome <- getBSgenome(genome)
#'         }
#'         # don't forget to return .Object
#'         .Object
#'     }
#' )
#'
#' setMethod(
#'     f = "processing",
#'     signature = "RandomRegionOnGenome",
#'     definition = function(.Object,...){
#'         # All arguments are set in .Object
#'         # so we can get them from .Object
#'         allparam <- list(...)
#'         sampleNumb <- getParam(.Object,"sampleNumb")
#'         regionLen <- getParam(.Object,"regionLen")
#'         bsgenome <- getParam(.Object,"bsgenome")
#'         outputBed <- getParam(.Object,"outputBed")
#'         # begin the calculation
#'         chrlens <-seqlengths(bsgenome)
#'         selchr <- grep("_|M",names(chrlens),invert=TRUE)
#'         chrlens <- chrlens[selchr]
#'         startchrlens <- chrlens - regionLen
#'         spchrs <- sample(x = names(startchrlens),size =  sampleNumb, replace = TRUE, prob = startchrlens / sum(startchrlens))
#'         gr <- GRanges()
#'         for(chr in names(startchrlens)){
#'             startpt <- sample(x = 1:startchrlens[chr],size = sum(spchrs == chr),replace = FALSE)
#'             gr <- c(gr,GRanges(seqnames = chr, ranges = IRanges(start = startpt, width = 1000)))
#'         }
#'         result <- sort(gr,ignore.strand=TRUE)
#'         rtracklayer::export.bed(object = result, con =  outputBed)
#'         # don't forget to return .Object
#'         .Object
#'     }
#' )
#'
#' # This function is exported in NAMESPACE for user to use
#' randomRegionOnGenome <- function(sampleNumb, regionLen = 1000, genome = NULL, outputBed = NULL, ...){
#'     allpara <- c(list(Class = "RandomRegionOnGenome", prevSteps = list()),as.list(environment()),list(...))
#'     step <- do.call(new,allpara)
#'     invisible(step)
#' }
#'
#'
#' # generate another new Step : OverlappedRandomRegion
#' setClass(Class = "OverlappedRandomRegion",
#'          contains = "Step"
#' )
#'
#' setMethod(
#'     f = "init",
#'     signature = "OverlappedRandomRegion",
#'     definition = function(.Object,prevSteps = list(),...){
#'         # All arguments in function overlappedRandomRegion and runOerlappedRandomRegion will be passed from "..."
#'         # so get the arguments from "..." first.
#'         allparam <- list(...)
#'         inputBed <- allparam[["inputBed"]]
#'         randomBed <- allparam[["randomBed"]]
#'         outputBed <- allparam[["outputBed"]]
#'         # inputBed can obtain from previous step object when running runOerlappedRandomRegion
#'         if(length(prevSteps)>0){
#'             prevStep <- prevSteps[[1]]
#'             .Object@inputList$randomBed <- getParam(prevStep,"outputBed")
#'         }
#'         # begin to set input parameters
#'         if(!is.null(inputBed)){
#'             .Object@inputList$inputBed <- inputBed
#'         }
#'         if(!is.null(randomBed)){
#'             .Object@inputList$randomBed <- randomBed
#'         }
#'         # begin to set output parameters
#'         # the output is recemended to set under the step work directory
#'         if(!is.null(outputBed)){
#'             .Object@outputList$outputBed <- outputBed
#'         }else{
#'             .Object@outputList$outputBed <- getAutoPath(.Object,.Object@inputList$inputBed, "bed", suffix = "bed")
#'             # the path can also be generate in this way
#'             # ib <- getParam(.Object,"inputBed")
#'             #.Object@outputList$outputBed <- file.path(getStepWorkDir(.Object),paste0(substring(ib,1,nchar(ib)-3), "bed"))
#'         }
#'         # begin to set other parameters
#'         # no other parameters
#'         # don't forget to return .Object
#'
#'
#'         .Object
#'     }
#' )
#' setMethod(
#'     f = "processing",
#'     signature = "OverlappedRandomRegion",
#'     definition = function(.Object,...){
#'         # All arguments are set in .Object
#'         # so we can get them from .Object
#'         allparam <- list(...)
#'         inputBed <- getParam(.Object,"inputBed")
#'         randomBed <- getParam(.Object,"randomBed")
#'         outputBed <- getParam(.Object,"outputBed")
#'
#'         # begin the calculation
#'         gr1 <- import.bed(con = inputBed)
#'         gr2 <- import.bed(con = randomBed)
#'         gr <- second(findOverlapPairs(gr1,gr2))
#'         export.bed(gr,con = outputBed)
#'         # don't forget to return .Object
#'         .Object
#'     }
#' )
#'
#'
#' # This function is exported in NAMESPACE for user to use
#' overlappedRandomRegion <- function(inputBed, randomBed, outputBed = NULL, ...){
#'     allpara <- c(list(Class = "OverlappedRandomRegion", prevSteps = list()),as.list(environment()),list(...))
#'     step <- do.call(new,allpara)
#'     invisible(step)
#' }
#'
#' setGeneric("runOverlappedRandomRegion",function(prevStep,
#'                                                 inputBed,
#'                                                 randomBed = NULL,
#'                                                 outputBed = NULL,
#'                                                 ...) standardGeneric("runOverlappedRandomRegion"))
#'
#'
#'
#' setMethod(
#'     f = "runOverlappedRandomRegion",
#'     signature = "Step",
#'     definition = function(prevStep,
#'                           inputBed,
#'                           randomBed = NULL,
#'                           outputBed = NULL,
#'                           ...){
#'         allpara <- c(list(Class = "OverlappedRandomRegion", prevSteps = list(prevStep)),as.list(environment()),list(...))
#'         step <- do.call(new,allpara)
#'         invisible(step)
#'     }
#' )
#'
#' # add to graph
#' addEdges(edges = c("RandomRegionOnGenome","OverlappedRandomRegion"),argOrder = 1)
#' # begin to test pipeline
#' setGenome("hg19")
#' rd <- randomRegionOnGenome(10000)
#' overlap <- runOverlappedRandomRegion(rd,inputBed = system.file(package = "pipeFrame", "extdata","testRegion.bed"))
#'
#' randombed <- getParam(rd,"outputBed")
#'
#' randombed
#'
#' overlap1 <-overlappedRandomRegion(inputBed = system.file(package = "pipeFrame", "extdata","testRegion.bed"),randomBed = randombed)
#'
#' clearStepCache(overlap1)
#' overlap1 <-overlappedRandomRegion(inputBed = system.file(package = "pipeFrame", "extdata","testRegion.bed"),randomBed = randombed)
#' clearStepCache(rd)
#' clearStepCache(overlap1)
#' rd <- randomRegionOnGenome(10000) %>%
#' runOverlappedRandomRegion(inputBed = system.file(package = "pipeFrame", "extdata","testRegion.bed"))
#'
#' getStepName(rd)
#' getStepId(rd)
#' getDefName(rd)
#'
#' isReady(rd)

#' @export Step
Step <- setClass(Class = "Step",
         slots = list(
             argv = "list",
             paramList = "list",
             inputList = "list",
             outputList = "list",
             propList = "list",
             reportVal = "list",
             stepName = "character",
             finish = "logical",
             timeStampStart="POSIXct",
             timeStampEnd="POSIXct",
             maxThreads = "integer",
             id = "integer",
             groupName = "character",
             loaded = "logical"
         ),
         prototype = c(argv = list(),
                       paramList = list(),
                       inputList = list(),
                       outputList = list(),
                       propList = list(),
                       reportVal = list(),
                       stepName = "Step",
                       finish = FALSE,
                       timeStampStart=Sys.time(),
                       timeStampEnd=Sys.time(),
                       maxThreads = 1L,
                       id = 0L,
                       groupName = character(),
                       loaded = FALSE)
         )
setMethod(f = "initialize",
          signature = "Step",
          definition = function(.Object,prevSteps = list(), groupName = NULL, ...){



              argv <- c(as.list(environment()),list(...))

              argv[["prevSteps"]] <- NULL





              stopifnot(is(prevSteps,"list"))
              if(length(prevSteps)>0){
                  objs<-unlist(prevSteps)
                  for(obj in objs){
                      if(is.null(obj)){
                          next
                      }
                      stopifnot(inherits(obj,"Step"))
                  }
              }

              stepName <- as.character(class(.Object))

              .Object@stepName <- stepName



              argvother <- argv[startsWith(names(argv),paste0(getDefName(.Object), "."))]
              for(a in names(argvother)){
                  a0 <- substring(a,1 + nchar(paste0(getDefName(.Object), ".")))
                  if(sum(names(argv)==a0)>0){
                      argv[[a0]] <- argvother[[a]]
                  }else{
                      stop(paste0(a," is not parameter of Step ", stepName))
                  }
              }
              .Object@argv <- argv


              argSize <- length(prevSteps)


              if(argSize>0){
                  for(i in 1:argSize){
                      if(!is.null(prevSteps[[i]]) && !isReady(prevSteps[[i]])){
                          stop(paste(getStepName(prevSteps[[i]]),"is not ready"))
                      }
                      # if(!checkRelation(getStepName(prevSteps[[i]]),getStepName(.Object),i)){
                      #     stop(paste(getStepName(prevSteps[[i]]),"is not valid input"))
                      # }
                      if(!is.null(prevSteps[[i]])){
                          .Object@propList <- c(.Object@propList, prevSteps[[i]]@propList)
                          .Object@groupName <- c(.Object@groupName, prevSteps[[i]]@groupName)
                      }
                  }
                  .Object@groupName <- sort(unique(.Object@groupName))
              }

              if(!is.null(groupName)){
                  stopifnot(!is.character(groupName))
                  .Object@groupName <- sort(unique(groupName))
              }

              if(is.null(groupName) && length(.Object@groupName)==0){
                  .Object@groupName <- "pipe"
              }






              nameObjList <- getOption("pipeFrameConfig.nameObjList")
              if(is.null(nameObjList)){
                  nameObjList <- list()
              }
              if(!is.null(nameObjList[[getDefName(.Object)]])){
                  .Object@id <- nameObjList[[getDefName(.Object)]]@id
              }else{
                  count <- getOption("pipeFrameConfig.count")
                  .Object@id <- count
              }
              options(pipeFrameConfig.allowChangeJobDir = FALSE)

              prevSteps <- list()
              for(i in 1:10){
                  s <- getPrevSteps(stepName = getStepName(.Object),i)
                  if(is.null(s)){
                      break
                  }
                  tt <- nameObjList[[paste0(s,"_",paste0(.Object@groupName,collapse = "_"))]]
                  if(is.null(tt)){
                      stop(paste("Step", s, " is required for", stepName, "please calculate Step",s,"first"))
                  }else{
                      prevSteps<-c(prevSteps,list(tt))
                  }
              }




              if(!dir.exists(getStepWorkDir(.Object))){
                  dir.create(getStepWorkDir(.Object))
              }

              argv <- c(list(.Object = .Object,prevSteps = prevSteps),argv)
              obj_return_from_init <- do.call(init,argv)
              stopifnot(is(obj_return_from_init,getStepName(.Object)))
              .Object <- obj_return_from_init
              paramValidation(.Object)
              obj_return_from_porcessing<-process(.Object)
              stopifnot(is(obj_return_from_porcessing,getStepName(.Object)))
              .Object <- obj_return_from_porcessing

              if(is.null(nameObjList[[getDefName(.Object)]])){
                  count <- getOption("pipeFrameConfig.count")
                  options(pipeFrameConfig.count = count+1L)
              }
              nameObjList[[getDefName(.Object)]] <- .Object
              options(pipeFrameConfig.nameObjList = nameObjList)
              .Object
          })

#' @return \item{init}{(For package developer only) A Step child class object with initialized input, output and other parameters}
#' @rdname Step-class
#' @aliases init
#' @export
setGeneric(name = "init",
           def = function(.Object,prevSteps = list(),...){
               standardGeneric("init")
           })


setMethod(f = "init",
          signature = "Step",
          definition = function(.Object,prevSteps = list(),...){
              stop("`init` function need to be implemented for inherit classes")
          })



setGeneric(name = "process",
           def = function(.Object,...){
               standardGeneric("process")
           })


setMethod(f = "process",
          signature = "Step",
          definition = function(.Object,...){
              msgBoxBegin()
              if(checkMD5Cache(.Object)){
                  writeLog(.Object,paste0("The step:`",.Object@stepName,"` was finished. Nothing to do."))
                  writeLog(.Object,"If you need to redo, please call 'clearStepCache(YourObject)'")
                  load(getParamMD5Path(.Object))
                  .Object <- pipeFrameObj
                  .Object@loaded <- TRUE
              }else{
                  writeLog(.Object,as.character(Sys.time()))
                  writeLog(.Object,paste0("start processing data: ", .Object@stepName))
                  .Object@timeStampStart<-Sys.time()
                  .Object <- processing(.Object)
                  .Object@timeStampEnd<-Sys.time()
                  .Object@reportVal$timeStampStart <- .Object@timeStampStart
                  .Object@reportVal$timeStampEnd <- .Object@timeStampEnd
                  .Object <- setFinish(.Object)
                  pipeFrameObj <- .Object
                  save(pipeFrameObj, file = getParamMD5Path(.Object))
              }
              msgBoxDone()
              .Object
          })



setGeneric(name = "getStepName",
           def = function(.Object,...){
               standardGeneric("getStepName")
           })

#' @return \item{getStepName}{get Step object Characher name}
#' @rdname Step-class
#' @aliases getStepName
#' @export
setMethod(f = "getStepName",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@stepName)
          })




setGeneric(name = "getDefName",
           def = function(.Object,...){
               standardGeneric("getDefName")
           })

#' @return \item{getDefName}{get Step object Characher name}
#' @rdname Step-class
#' @aliases getDefName
#' @export
setMethod(f = "getDefName",
          signature = "Step",
          definition = function(.Object,...){
              return(paste0(.Object@stepName,"_",paste0(.Object@groupName,collapse = "_")))
          })

setGeneric(name = "getParam",
           def = function(.Object,item,...){
               standardGeneric("getParam")
           })

#' @rdname Step-class
#' @return \item{getParam}{Get parameter value set by process function.
#' See \code{getParamItems} to obtain valid item for query.}
#' @aliases  getParam
#' @export
setMethod(f = "getParam",
          signature = "Step",
          definition = function(.Object,item, type = c("input","output","other"),...){
              type <- unique(type)
              for(t in type){
                  t1 <- match.arg(t,c("input","output","other"))
                  if(t1 == "input"){
                      if(!is.null(.Object@inputList[[item]])){
                          return(.Object@inputList[[item]])
                      }
                  }else if(t1 == "output"){
                      if(!is.null(.Object@outputList[[item]])){
                          return(.Object@outputList[[item]])
                      }
                  }else{
                      if(!is.null(.Object@paramList[[item]])){
                          return(.Object@paramList[[item]])
                      }
                  }
              }
              return(NULL)
          })

setGeneric(name = "getParamItems",
           def = function(.Object, type = c("input","output","other"),...){
               standardGeneric("getParamItems")
           })

#' @rdname Step-class
#' @return \item{getParamItems}{Get parameter name list}
#' @aliases  getParamItems
#' @export
setMethod(f = "getParamItems",
          signature = "Step",
          definition = function(.Object, type = c("input","output","other"), ...){
              type <- unique(type)
              allitem <- c()
              for(t in type){
                  t1 <- match.arg(t,c("input","output","other"))
                  if(t1 == "input"){
                      allitem <- c(allitem,names(.Object@inputList))
                  }else if(t1 == "output"){
                      allitem <- c(allitem,names(.Object@outputList))
                  }else{
                      allitem <- c(allitem,names(.Object@paramList))
                  }
              }

              return(allitem)
          })



setGeneric(name = "isReady",
           def = function(.Object,...){
               standardGeneric("isReady")
           })

#' @rdname Step-class
#' @return \item{isReady}{Is the process ready for downstream process}
#' @aliases  isReady
#' @export
setMethod(f = "isReady",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@finish)
          })


setGeneric(name = "clearStepCache",
           def = function(.Object,...){
               standardGeneric("clearStepCache")
           })

#' @rdname Step-class
#' @return \item{clearStepCache}{Clear cache of Step object}
#' @aliases  clearStepCache
#' @export
setMethod(f = "clearStepCache",
          signature = "Step",
          definition = function(.Object,...){
              if(!unlink(getParamMD5Path(.Object))){
                  message("Chache has been cleared")
              }else{
                  message("Chache does not exist. Nothing has been done.")
              }
              outItems <-getParamItems(.Object,type="output")
              for(item in outItems){
                  unlink(normalizePath(unlist(getParam(.Object,item))),recursive = TRUE)
              }
              .Object@finish<-FALSE
              .Object
          })



setGeneric(name = "getReportVal",
           def = function(.Object,item,...){
               standardGeneric("getReportVal")
           })

#' @rdname Step-class
#' @return \item{getReportVal}{Get report value of item.
#' See \code{getReportItems} to obtain valid item for query.}
#' @aliases   getReportVal
#' @export
setMethod(f = "getReportVal",
          signature = "Step",
          definition = function(.Object,item,...){
              if(.Object@finish){
                  if(sum(item == getReportItemsImp(.Object))>0){
                      return(getReportValImp(.Object,item))
                  }else{
                      stop(paste0(item," is not an item of report value."))
                  }
              }else{
                  stop("Unfinished process is not available for report value.")
              }
          })


setGeneric(name = "getReportItems",
           def = function(.Object,...){
               standardGeneric("getReportItems")
           })

#' @rdname Step-class
#' @return \item{getReportItems}{Get all items that can be reported}
#' @aliases getReportItems
#' @export
setMethod(f = "getReportItems",
          signature = "Step",
          definition = function(.Object,...){
              if(.Object@finish){
                  return(getReportItemsImp(.Object))
              }else{
                  stop("Unfinished process is not available for report items.")
              }
          })
setGeneric(name = "getAutoPath",
           def = function(.Object,originPath,regexSuffixName,suffix,...){
               standardGeneric("getAutoPath")
           })

#' @return \item{getAutoPath}{(For package developer)Developer can use this method to generate new file name based on exist input file name}
#' @rdname Step-class
#' @aliases getAutoPath
#' @export
setMethod(f = "getAutoPath",
          signature = "Step",
          definition = function(.Object,originPath,regexSuffixName,suffix,...){
              stopifnot(is.character(originPath))
              prefix<-getBasenamePrefix(originPath,regexSuffixName)
              return(file.path(getStepWorkDir(.Object),paste0(prefix,".",suffix)))
          })
setGeneric(name = "paramValidation",
           def = function(.Object,...){
               standardGeneric("paramValidation")
           })
setMethod(f = "paramValidation",
          signature = "Step",
          definition = function(.Object,...){
              if(!checkMD5Cache(.Object)){
                  checkAllPath(.Object)
              }
              checkRequireParam(.Object);
          })

#' @return \item{checkRequireParam}{(For package developer) Check required inputs are filled.}
#' @rdname Step-class
#' @aliases checkRequireParam
#' @export
setGeneric(name = "checkRequireParam",
           def = function(.Object,...){
               standardGeneric("checkRequireParam")
           })

setMethod(f = "checkRequireParam",
          signature = "Step",
          definition = function(.Object,...){
              items <- getParamItems(.Object, type="input")
              for(items in items){

              }
          })


#' @return \item{checkRequireParam}{(For package developer) Check required inputs are filled.}
#' @rdname Step-class
#' @aliases checkAllPath
#' @export
setGeneric(name = "checkAllPath",
           def = function(.Object,...){
               standardGeneric("checkAllPath")
           })

setMethod(f = "checkAllPath",
          signature = "Step",
          definition = function(.Object,...){
              items <- getParamItems(.Object, type="input")
              for(items in items){

              }
          })

setGeneric(name = "getParamMD5Path",
           def = function(.Object,...){
               standardGeneric("getParamMD5Path")
           })
#' @return \item{getParamMD5Path}{The Step object storage directory}
#' @rdname Step-class
#' @aliases getParamMD5Path
#' @export
setMethod(f = "getParamMD5Path",
          signature = "Step",
          definition = function(.Object,...){
              paramstr <- c(getStepName(.Object))
              itNames <- getParamItems(.Object,type="other")
              for(n in sort(itNames)){
                  paramstr<-c(paramstr,n)
                  paramstr<-c(paramstr,getParam(.Object,n,type="other"))
              }
              ioNames <- getParamItems(.Object,type=c("input","output"))
              for(n in sort(ioNames)){
                  paramstr<-c(paramstr,n)
                  paths <- getParam(.Object,n,type = c("input","output"))
                  if(!is.character(paths) && !is.list(paths)){
                      paramstr <- c(paramstr,paths)
                      next
                  }
                  paths <- sort(unlist(paths))
                  paths1 <- c()
                  breakflag <- FALSE
                  for(path in paths){
                      if(dir.exists(path)){
                          paths1 <- c(paths1, sort(dir(path,recursive = TRUE)))
                      }else if(file.exists(path)){
                          paths1 <- c(paths1, path)
                      }else{
                          paramstr <- c(paramstr,runif(1))
                          breakflag <- TRUE
                          break;
                      }
                  }
                  if(breakflag){
                      break
                  }
                  paths <- paths1
                  paths <- paths[grep("pipeFrame.obj",paths,invert = TRUE)]
                  checkpaths <- c()
                  for(path in paths){
                      p <- normalizePath(path)
                      checkpaths <- c(checkpaths,p)
                      if(startsWith(p,getJobDir())){
                          p <- substring(p,2+nchar(getJobDir()))
                      }
                      paramstr <- c(paramstr,p)
                  }
                  for(p in checkpaths){
                      filesize <- file.info(p)$size
                      paramstr <- c(paramstr,filesize)
                  }
              }
              md5code<-substr(digest(object = paramstr,algo = "md5"),1,8)
              md5filepath<-file.path(getStepWorkDir(.Object),paste("pipeFrame.obj",md5code,"RData",sep = "."))
              return(md5filepath)
          })
setGeneric(name = "setFinish",
           def = function(.Object,...){
               standardGeneric("setFinish")
           })
setMethod(f = "setFinish",
          signature = "Step",
          definition = function(.Object,...){
              .Object@finish<-TRUE
              writeLog(.Object,as.character(Sys.time()))
              writeLog(.Object,"processing finished")
              .Object
          })
setGeneric(name = "checkMD5Cache",
           def = function(.Object,...){
               standardGeneric("checkMD5Cache")
           })
setMethod(f = "checkMD5Cache",
          signature = "Step",
          definition = function(.Object,...){
              if(file.exists(getParamMD5Path(.Object))){
                  return(TRUE)
              }else{
                  return(FALSE)
              }
          })

setGeneric(name = "getStepWorkDir",
           def = function(.Object, filename = NULL, ...){
               standardGeneric("getStepWorkDir")
           })
#' @return \item{getStepWorkDir}{Get the step work directory of this object}
#' @rdname Step-class
#' @aliases getStepWorkDir
#' @export
setMethod(f = "getStepWorkDir",
          signature = "Step",
          definition = function(.Object, filename = NULL, ...){
              if(is.null(filename)){
                  return(file.path(getJobDir(),paste0("Step_",sprintf("%02d",getStepId(.Object)),"_",getDefName(.Object))))
              }else{
                  return(file.path(getJobDir(),paste0("Step_",sprintf("%02d",getStepId(.Object)),"_",getDefName(.Object)),filename))
              }

          })

setGeneric(name = "getStepId",
           def = function(.Object,...){
               standardGeneric("getStepId")
           })

#' @return \item{getStepId}{Get the step ID}
#' @rdname Step-class
#' @aliases getStepId
#' @export
setMethod(f = "getStepId",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@id)
          })



setGeneric(name = "writeLog",
           def = function(.Object,msg,...,isWarnning=FALSE,appendLog=TRUE,showMsg=TRUE){
               standardGeneric("writeLog")
           })
#' @return \item{writeLog}{(For package developer) write log.}
#' @rdname Step-class
#' @aliases writeLog
#' @export
setMethod(f = "writeLog",
          signature = "Step",
          definition = function(.Object,msg,...,isWarnning=FALSE,appendLog=TRUE,showMsg=TRUE){
              if(isWarnning){
                  warning(msg)
                  msg<-paste0("Warning:",msg)
              }else if(showMsg){
                  message(msg)
              }
              write.table(msg,file.path(getStepWorkDir(.Object),"pipeFrame.obj.log"),quote = FALSE,row.names = FALSE,col.names = FALSE,append = appendLog)
              .Object
          })

#' @return \item{processing}{(For package developer) Run pipeline step}
#' @rdname Step-class
#' @aliases processing
#' @export
setGeneric(name = "processing",
           def = function(.Object,...){
               standardGeneric("processing")
           })




#' @return \item{getReportValImp}{(For package developer) get Report Value}
#' @rdname Step-class
#' @aliases getReportValImp
#' @export
setGeneric(name = "getReportValImp",
           def = function(.Object,item,...){
               standardGeneric("getReportValImp")
           })


setMethod(f = "getReportValImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(.Object@reportVal[[item]])
          })

#' @return \item{getReportItemsImp}{(For package developer) getReportItemsImp}
#' @rdname Step-class
#' @aliases getReportItemsImp
#' @export
setGeneric(name = "getReportItemsImp",
           def = function(.Object,item,...){
               standardGeneric("getReportItemsImp")
           })


setMethod(f = "getReportItemsImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(names(.Object@reportVal))
          })




