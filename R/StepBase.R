setClass(Class = "Step",
         slots = list(
             argv = "list",
             paramList = "list",
             inputList = "list",
             outputList = "list",
             propList = "list",
             reportVal = "list",
             stepName = "character",
             finish = "logical",
             logRecord= "character",
             timeStampStart="character",
             timeStampEnd="character",
             maxThreads = "integer",
             id = "integer"
         ),
         prototype = list(
             argv = list(),
             paramList = list(),
             inputList = list(),
             outputList = list(),
             propList = list(),
             reportVal = list(),
             stepName = "Step",
             finish = FALSE,
             logRecord= "Generated by pipeFrame",
             timeStampStart="Never Record",
             timeStampEnd="Never Record",
             maxThreads = 1L,
             id = 0L
         ))
setMethod(f = "initialize",
          signature = "Step",
          definition = function(.Object,prevSteps,...){

              argv <- c(as.list(environment()),list(...))

              stepName <- as.character(class(.Object))

              .Object@stepName <- stepName

              argvother <- argv[startsWith(paste0(names(argv),"."),stepName)]
              for(a in names(argvother)){
                  a0 <- substring(a,2 + nchar(stepName))
                  if(sum(names(argv)==a0)>0){
                      argv[[a0]] <- argvother[[a]]
                  }
              }
              .Object@argv <- argv
              argv <- c(list(.Object = .Object),argv)

              argSize <- length(prevSteps)

              if(argSize>0){
                  for(i in 1:argSize){
                      if(!is.null(prevSteps[[i]]) && !isReady(prevSteps[[i]])){
                          stop(paste(getStepName(prevSteps[[i]]),"is not ready"))
                      }
                      if(!checkRelation(getStepName(prevSteps[[i]]),getStepName(.Object),i)){
                          stop(paste(getStepName(prevSteps[[i]]),"is not valid input"))
                      }
                      .Object@propList <- c(.Object@propList, prevSteps[[i]]@propList)
                  }
              }
              message("point1.2")
              count <- getOption("pipeFrameConfig.count")
              .Object@id <- count
              options(pipeFrameConfig.count = count+1L)
              options(pipeFrameConfig.allowChangeJobDir = FALSE)
              if(!dir.exists(getStepWorkDir(.Object))){
                  message("create")
                  print(getStepWorkDir(.Object))
                  dir.create(getStepWorkDir(.Object))
              }
              message("point2")
              print(names(argv))

              print(argv)
              obj_return_from_init <- do.call(init,argv)
              stopifnot(is(obj_return_from_init,getStepName(.Object)))
              .Object <- obj_return_from_init
              paramValidation(.Object)
              message("point3")
              obj_return_from_porcessing<-process(.Object)
              stopifnot(is(obj_return_from_porcessing,getStepName(.Object)))
              .Object <- obj_return_from_porcessing
              message("point1")
              .Object
          })


setGeneric(name = "init",
           def = function(.Object,prevSteps,...){
               standardGeneric("init")
           })



setGeneric(name = "process",
           def = function(.Object,...){
               standardGeneric("process")
           })

#' @return \item{process}{Call this function to redo processing }
#' @rdname Step-class
#' @aliases process
#' @export
setMethod(f = "process",
          signature = "Step",
          definition = function(.Object,...){
              msgBoxBegin()
              if(checkMD5Cache(.Object)){
                  message(paste0("The process:`",.Object@stepName,"` was finished. Nothing to do."))
                  message("If you need to redo, please call 'clearProcCache(YourObject)'")
                  .Object@finish<-TRUE
              }else{
                  .Object <- writeLog(.Object,as.character(Sys.time()))
                  .Object <- writeLog(.Object,paste0("start processing data: ", .Object@stepName))
                  .Object <- processing(.Object)
                  .Object <- setFinish(.Object)
              }
              msgBoxDone()
              .Object
          })



setGeneric(name = "getStepName",
           def = function(.Object,...){
               standardGeneric("getStepName")
           })

#' @return \item{getStepName}{get Step object Characher name}
#' @rdname Step-class
#' @aliases getStepName
#' @export
setMethod(f = "getStepName",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@stepName)
          })

setGeneric(name = "getParam",
           def = function(.Object,item,...){
               standardGeneric("getParam")
           })

#' @rdname Step-class
#' @return \item{getParam}{Get parameter value set by process function.
#' See \code{getParamItems} to obtain valid item for query.}
#' @aliases  getParam
#' @export
setMethod(f = "getParam",
          signature = "Step",
          definition = function(.Object,item, type = c("input","output","other"),...){
              type <- unique(type)
              for(t in type){
                  t1 <- match(t,c("input","output","other"))
                  t1 <- c("input","output","other")[t1]
                  if(t1 == "input"){
                      if(!is.null(.Object@inputList[[item]])){
                          return(.Object@inputList[[item]])
                      }
                  }else if(t1 == "output"){
                      if(!is.null(.Object@outputList[[item]])){
                          return(.Object@outputList[[item]])
                      }
                  }else{
                      if(!is.null(.Object@paramList[[item]])){
                          return(.Object@paramList[[item]])
                      }
                  }
              }
              return(NULL)
          })

setGeneric(name = "getParamItems",
           def = function(.Object, type = c("input","output","other"),...){
               standardGeneric("getParamItems")
           })

#' @rdname Step-class
#' @return \item{getParamItems}{Get parameter name list}
#' @aliases  getParamItems
#' @export
setMethod(f = "getParamItems",
          signature = "Step",
          definition = function(.Object, type = c("input","output","other"), ...){
              type <- unique(type)
              print(type)
              allitem <- c()
              for(t in type){
                  print(t)
                  t1 <- match(t,c("input","output","other"))
                  t1 <- c("input","output","other")[t1]
                  if(t1 == "input"){
                      allitem <- c(allitem,names(.Object@inputList))
                      print("iii")
                  }else if(t1 == "output"){
                      allitem <- c(allitem,names(.Object@outputList))
                      print("ooo")
                  }else{
                      allitem <- c(allitem,names(.Object@paramList))
                      print("ppp")
                  }
              }
              print(allitem)
              return(allitem)
          })



setGeneric(name = "isReady",
           def = function(.Object,...){
               standardGeneric("isReady")
           })

#' @rdname Step-class
#' @return \item{isReady}{Is the process ready for downstream process}
#' @aliases  isReady
#' @export
setMethod(f = "isReady",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@finish)
          })


setGeneric(name = "clearProcCache",
           def = function(.Object,...){
               standardGeneric("clearProcCache")
           })

#' @rdname Step-class
#' @return \item{clearProcCache}{Clear cache of atacProc object}
#' @aliases  clearProcCache
#' @export
setMethod(f = "clearProcCache",
          signature = "Step",
          definition = function(.Object,...){
              if(!unlink(getParamMD5Path(.Object))){
                  message("Chache has been cleared")
              }else{
                  message("Chache does not exist. Nothing has been done.")
              }
              outItems <-getParamItems(.Object,type="output")
              for(item in outItems){
                  unlink(normalizePath(unlist(getParam(item))),recursive = TRUE)
              }
              .Object@finish<-FALSE
              .Object
          })



setGeneric(name = "getReportVal",
           def = function(.Object,item,...){
               standardGeneric("getReportVal")
           })

#' @rdname Step-class
#' @return \item{getReportVal}{Get report value of item.
#' See \code{getReportItems} to obtain valid item for query.}
#' @aliases   getReportVal
#' @export
setMethod(f = "getReportVal",
          signature = "Step",
          definition = function(.Object,item,...){
              if(.Object@finish){
                  if(sum(item == getReportItemsImp(.Object))>0){
                      return(getReportValImp(.Object,item))
                  }else{
                      stop(paste0(item," is not an item of report value."))
                  }
              }else{
                  stop("Unfinished process is not available for report value.")
              }
          })


setGeneric(name = "getReportItems",
           def = function(.Object,...){
               standardGeneric("getReportItems")
           })

#' @rdname Step-class
#' @return \item{getReportItems}{Get all items that can be reported}
#' @aliases getReportItems
#' @export
setMethod(f = "getReportItems",
          signature = "Step",
          definition = function(.Object,...){
              if(.Object@finish){
                  return(getReportItemsImp(.Object))
              }else{
                  stop("Unfinished process is not available for report items.")
              }
          })
setGeneric(name = "getAutoPath",
           def = function(.Object,originPath,regexProcName,suffix,...){
               standardGeneric("getAutoPath")
           })
setMethod(f = "getAutoPath",
          signature = "Step",
          definition = function(.Object,originPath,regexProcName,suffix,...){
              stopifnot(is.character(originPath))
              prefix<-getBasenamePrefix(originPath,regexProcName)
              return(file.path(getStepWorkDir(.Object),paste0(prefix,".",suffix)))
          })
setGeneric(name = "paramValidation",
           def = function(.Object,...){
               standardGeneric("paramValidation")
           })
setMethod(f = "paramValidation",
          signature = "Step",
          definition = function(.Object,...){
              if(!checkMD5Cache(.Object)){
                  checkAllPath(.Object)
              }
              checkRequireParam(.Object);
          })
setGeneric(name = "checkRequireParam",
           def = function(.Object,...){
               standardGeneric("checkRequireParam")
           })



setGeneric(name = "checkAllPath",
           def = function(.Object,...){
               standardGeneric("checkAllPath")
           })

setMethod(f = "checkAllPath",
          signature = "Step",
          definition = function(.Object,...){
              items <- getParamItems(.Object, type="intput")
              for(items in items){

              }
          })

checkFileExist <- function(filePath,...){
    filePath <- unlist(filePath)
    stopifnot(!is.null(filePath))
    for(p in filePath){
        if(!file.exists(p)){
            stop(paste("error, file does not exist:",p))
        }
    }
}
checkPathExist <- function(filePath,...){
    filePath <- unlist(filePath)
    stopifnot(!is.null(filePath))
    for(p in filePath){
        if(!dir.exists(dirname(p))){
            stop(paste("error, path does not exist:",p))
        }
    }
}
checkFileCreatable <- function(filePath,...){
    filePaths <- unlist(filePath)
    stopifnot(!is.null(filePaths))
    for(filePath in filePaths){
        if(file.exists(filePath)){
            warning(paste("file exist:",filePath,". It may be overwrited in processing"))
        }else if(!file.create(filePath)){
            stop(paste("cannot create file '",filePath,"', No such file or directory or permission denied"))
        }else{
            unlink(filePath)
        }
    }
}
checkParam <- function(paramList,paramPattern,...){
    rs<-grepl(paramPattern, paramList)
    if(sum(rs)>0){
        banp=paste(paramList[rs], collapse = "'/'")
        stop(sprintf("Parameter(s) '%s' are not acceptable in paramList. it should be set as fix parameter.",banp))
    }
}
setGeneric(name = "getParamMD5Path",
           def = function(.Object,...){
               standardGeneric("getParamMD5Path")
           })
setMethod(f = "getParamMD5Path",
          signature = "Step",
          definition = function(.Object,...){
              paramstr <- c(getStepName(.Object))
              itNames <- getParamItems(.Object,type="other")
              for(n in sort(itNames)){
                  paramstr<-c(paramstr,n)
                  paramstr<-c(paramstr,getParam(.Object,n,type="other"))
              }
              ioNames <- getParamItems(.Object,type=c("input","output"))
              for(n in sort(ioNames)){
                  paramstr<-c(paramstr,n)
                  paths <- getParam(.Object,n,type = c("input","output"))
                  print(n)
                  print(paths)
                  paths <- sort(unlist(paths))
                  paths1 <- c()
                  breakflag <- FALSE
                  for(path in paths){
                      if(dir.exists(path)){
                          paths1 <- c(paths1, sort(dir(path,recursive = TRUE)))
                      }else if(file.exists(path)){
                          paths1 <- c(paths1, path)
                      }else{
                          paramstr <- c(paramstr,runif(1))
                          breakflag <- TRUE
                          break;
                      }
                  }
                  if(breakflag){
                      break
                  }
                  paths <- paths1
                  paths <- paths[grep("pipeFrame.md5",paths,invert = TRUE)]
                  checkpaths <- c()
                  for(path in paths){
                      p <- normalizePath(path)
                      checkpaths <- c(checkpaths,p)
                      if(startsWith(p,getJobDir())){
                          p <- substring(p,2+nchar(getJobDir()))
                      }
                      paramstr <- c(paramstr,p)
                  }
              }
              flag = FALSE
              for(p in checkpaths){
                  filesize <- file.info(p)$size
                  paramstr <- c(paramstr,filesize)
              }
              md5code<-substr(digest(object = paramstr,algo = "md5"),1,8)
              md5filepath<-file.path(getStepWorkDir(.Object),paste("pipeFrame.md5",md5code,"log",sep = "."))
              return(md5filepath)
          })
setGeneric(name = "setFinish",
           def = function(.Object,...){
               standardGeneric("setFinish")
           })
setMethod(f = "setFinish",
          signature = "Step",
          definition = function(.Object,...){
              .Object@finish<-TRUE
              .Object<-writeLog(.Object,as.character(Sys.time()))
              .Object<-writeLog(.Object,"processing finished")
              logFilePath<-getParamMD5Path(.Object)
              write.table(.Object@logRecord,logFilePath,quote = FALSE,row.names = FALSE,col.names = FALSE)
              .Object
          })
setGeneric(name = "checkMD5Cache",
           def = function(.Object,...){
               standardGeneric("checkMD5Cache")
           })
setMethod(f = "checkMD5Cache",
          signature = "Step",
          definition = function(.Object,...){
              if(file.exists(getParamMD5Path(.Object))){
                  return(TRUE)
              }else{
                  return(FALSE)
              }
          })

setGeneric(name = "getStepWorkDir",
           def = function(.Object,...){
               standardGeneric("getStepWorkDir")
           })
setMethod(f = "getStepWorkDir",
          signature = "Step",
          definition = function(.Object,...){
              message(getStepId(.Object))
              return(file.path(getJobDir(),paste0("Step_",sprintf("%02d",getStepId(.Object)),"_",getStepName(.Object))))
          })

setGeneric(name = "getStepId",
           def = function(.Object,...){
               standardGeneric("getStepId")
           })
setMethod(f = "getStepId",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@id)
          })


getBasenamePrefix <- function(filepath,words,...){
    return(basename(gsub(paste0("[.]",words,".*"),"",filepath)))
}

getPathPrefix <- function(filepath,words,...){
    return(gsub(paste0("[.]",words,".*"),"",filepath))
}

setGeneric(name = "writeLog",
           def = function(.Object,msg,...,isWarnning=FALSE,appendLog=TRUE,showMsg=TRUE){
               standardGeneric("writeLog")
           })
setMethod(f = "writeLog",
          signature = "Step",
          definition = function(.Object,msg,...,isWarnning=FALSE,appendLog=TRUE,showMsg=TRUE){
              if(isWarnning){
                  warning(msg)
                  msg<-paste0("Warning:",msg)
              }else if(showMsg){
                  message(msg)
              }
              if(appendLog){
                  .Object@logRecord<-c(.Object@logRecord,msg)
              }else{
                  .Object@logRecord<-msg
              }
              .Object
          })
setGeneric(name = "processing",
           def = function(.Object,...){
               standardGeneric("processing")
           })

setGeneric(name = "getReportValImp",
           def = function(.Object,item,...){
               standardGeneric("getReportValImp")
           })
setMethod(f = "getReportValImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(.Object@reportVal[[item]])
          })
setGeneric(name = "getReportItemsImp",
           def = function(.Object,item,...){
               standardGeneric("getReportItemsImp")
           })
setMethod(f = "getReportItemsImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(names(.Object@reportVal))
          })




msgBoxBegin<-function(){
    message(">>>>>>========================================")
}

msgBoxDone<-function(){
    message("========================================<<<<<<")
    message(" ")
}
