#' @importFrom digest digest
#' @importFrom methods new
#' @importFrom stats runif
#' @importFrom stats na.omit
#' @importFrom methods is
#' @importFrom utils write.table
#' @name Step-class
#' @rdname  Step-class
#' @title Methods for Step objects
#' @description
#' Users can call Step object operation methods below
#' to obtain information in objects.
#' @details
#' \code{Step} is a S4 class for generating Step S4 objects.
#' All Step objects generated by child classes inherit from Step.
#' To generate new Step objects,
#' a function wrapper with fixed arguments needs to be implemented.
#'  Users use this function to generate new Step functions rather
#'  than Step S4 class to generate objects.
#' @author Zheng Wei
#' @seealso

#' \code{\link{setGenome}}
#' \code{\link{setThreads}}


#' @param .Object \code{Step} object scalar.
#' Step object is returned by functions in each step.
#' @param prevSteps \code{List} scalar of Step object
#' @param type \code{Character} scalar.
#' Valid types of parameters including "input", "output" and "other"
#' @param item \code{Character} scalar.
#' The items in parameter list or report list.
#' @param originPath \code{Character} scalar.
#' The file name for output file is based on this original path name.
#' @param regexSuffixName \code{Character} scalar. The suffix for replacement.
#' @param suffix \code{Character} scalar. The new suffix for the file.
#' @param msg \code{Character} scalar. The message to write into log file.
#' @param isWarnning \code{Logical} scalar. Set this message as warning message.
#' Default: FALSE
#' @param appendLog \code{Logical} scalar. Append to the log file.
#' Default: TRUE
#' @param showMsg \code{Logical} scalar. Show the message on screen.
#' Default: TRUE
#' @param filename \code{Character} scaler.
#' The name of file under step working directiory
#' @param ... Additional arguments, currently unused.
#' @return the function and result of functions:
#'
#' @examples
#'
#'
#' library(BSgenome)
#' library(rtracklayer)
#' library(magrittr)
#'
#' # generate new Step : RandomRegionOnGenome
#' setClass(Class = "RandomRegionOnGenome",
#'          contains = "Step"
#' )
#'
#' setMethod(
#'     f = "init",
#'     signature = "RandomRegionOnGenome",
#'     definition = function(.Object,prevSteps = list(),...){
#'         # All arguments in function randomRegionOnGenome
#'         # will be passed from "..."
#'         # so get the arguments from "..." first.
#'         allparam <- list(...)
#'         sampleNumb <- allparam[["sampleNumb"]]
#'         regionLen <- allparam[["regionLen"]]
#'         genome <- allparam[["genome"]]
#'         outputBed <- allparam[["outputBed"]]
#'         # no previous steps for this step so ingnore the "prevSteps"
#'         # begin to set input parameters
#'         # no input for this step
#'         # begin to set output parameters
#'         if(is.null(outputBed)){
#'             .Object <- setOutput(.Object, "outputBed",
#'                 getStepWorkDir(.Object,"random.bed"))
#'         }else{
#'             .Object <- setOutput(.Object, "outputBed", outputBed)
#'         }
#'         # begin to set other parameters
#'         .Object <- setParam(.Object, "regionLen", regionLen)
#'         .Object <- setParam(.Object, "sampleNumb" , sampleNumb)
#'         if(is.null(genome)){
#'             .Object <- setParam(.Object, "bsgenome" , getBSgenome(getGenome()))
#'         }else{
#'             .Object <- setParam(.Object, "bsgenome" , getBSgenome(genome))
#'         }
#'         # don't forget to return .Object
#'         .Object
#'     }
#' )
#'
#' setMethod(
#'     f = "processing",
#'     signature = "RandomRegionOnGenome",
#'     definition = function(.Object,...){
#'         # All arguments are set in .Object
#'         # so we can get them from .Object
#'         allparam <- list(...)
#'         sampleNumb <- getParam(.Object,"sampleNumb")
#'         regionLen <- getParam(.Object,"regionLen")
#'         bsgenome <- getParam(.Object,"bsgenome")
#'         outputBed <- getParam(.Object,"outputBed")
#'         # begin the calculation
#'         chrlens <-seqlengths(bsgenome)
#'         selchr <- grep("_|M",names(chrlens),invert=TRUE)
#'         chrlens <- chrlens[selchr]
#'         startchrlens <- chrlens - regionLen
#'         spchrs <- sample(x = names(startchrlens),
#'         size =  sampleNumb, replace = TRUE,
#'         prob = startchrlens / sum(startchrlens))
#'         gr <- GRanges()
#'         for(chr in names(startchrlens)){
#'             startpt <- sample(x = 1:startchrlens[chr],
#'             size = sum(spchrs == chr),replace = FALSE)
#'             gr <- c(gr,GRanges(seqnames = chr,
#'             ranges = IRanges(start = startpt, width = 1000)))
#'         }
#'         result <- sort(gr,ignore.strand=TRUE)
#'         rtracklayer::export.bed(object = result, con =  outputBed)
#'         # don't forget to return .Object
#'         .Object
#'     }
#' )
#'
#' # This function is exported in NAMESPACE for user to use
#' randomRegionOnGenome <- function(sampleNumb, regionLen = 1000,
#'                                  genome = NULL, outputBed = NULL, ...){
#'     allpara <- c(list(Class = "RandomRegionOnGenome", prevSteps = list()),
#'                  as.list(environment()),list(...))
#'     step <- do.call(new,allpara)
#'     invisible(step)
#' }
#'
#'
#' # generate another new Step : OverlappedRandomRegion
#' setClass(Class = "OverlappedRandomRegion",
#'          contains = "Step"
#' )
#'
#' setMethod(
#'     f = "init",
#'     signature = "OverlappedRandomRegion",
#'     definition = function(.Object,prevSteps = list(),...){
#'         # All arguments in function overlappedRandomRegion and
#'         # runOerlappedRandomRegion will be passed from "..."
#'         # so get the arguments from "..." first.
#'         allparam <- list(...)
#'         inputBed <- allparam[["inputBed"]]
#'         randomBed <- allparam[["randomBed"]]
#'         outputBed <- allparam[["outputBed"]]
#'         # inputBed can obtain from previous step object when running
#'         # runOerlappedRandomRegion
#'         if(length(prevSteps)>0){
#'             prevStep <- prevSteps[[1]]
#'             .Object <- setInput(.Object, "randomBed" , getParam(prevStep,"outputBed"))
#'         }
#'         # begin to set input parameters
#'         if(!is.null(inputBed)){
#'             .Object <- setInput(.Object, "inputBed", inputBed)
#'         }
#'         if(!is.null(randomBed)){
#'             .Object <- setInput(.Object, "randomBed", randomBed)
#'         }
#'         # begin to set output parameters
#'         # the output is recemended to set under the step work directory
#'         if(!is.null(outputBed)){
#'             .Object <- setOutput(.Object, "outputBed" , outputBed)
#'         }else{
#'             .Object <- setOutput(.Object,"outputBed",
#'                 getAutoPath(.Object, getParam(.Object, "inputBed"),
#'                             "bed", suffix = "bed"))
#'             # the path can also be generate in this way
#'             # ib <- getParam(.Object,"inputBed")
#'             # Object <- setOutput(.Object,"outputBed",
#'             #    file.path(getStepWorkDir(.Object),
#'             #    paste0(substring(ib,1,nchar(ib)-3), "bed")))
#'         }
#'         # begin to set other parameters
#'         # no other parameters
#'         # don't forget to return .Object
#'
#'
#'         .Object
#'     }
#' )
#' setMethod(
#'     f = "processing",
#'     signature = "OverlappedRandomRegion",
#'     definition = function(.Object,...){
#'         # All arguments are set in .Object
#'         # so we can get them from .Object
#'         allparam <- list(...)
#'         inputBed <- getParam(.Object,"inputBed")
#'         randomBed <- getParam(.Object,"randomBed")
#'         outputBed <- getParam(.Object,"outputBed")
#'
#'         # begin the calculation
#'         gr1 <- import.bed(con = inputBed)
#'         gr2 <- import.bed(con = randomBed)
#'         gr <- second(findOverlapPairs(gr1,gr2))
#'         export.bed(gr,con = outputBed)
#'         # don't forget to return .Object
#'         .Object
#'     }
#' )
#'
#'
#' # This function is exported in NAMESPACE for user to use
#' overlappedRandomRegion <- function(inputBed, randomBed,
#'                                    outputBed = NULL, ...){
#'     allpara <- c(list(Class = "OverlappedRandomRegion",
#'         prevSteps = list()),as.list(environment()),list(...))
#'     step <- do.call(new,allpara)
#'     invisible(step)
#' }
#'
#' setGeneric("runOverlappedRandomRegion",
#'            function(prevStep,
#'                     inputBed,
#'                     randomBed = NULL,
#'                     outputBed = NULL,
#'                     ...) standardGeneric("runOverlappedRandomRegion"))
#'
#'
#'
#' setMethod(
#'     f = "runOverlappedRandomRegion",
#'     signature = "Step",
#'     definition = function(prevStep,
#'                           inputBed,
#'                           randomBed = NULL,
#'                           outputBed = NULL,
#'                           ...){
#'         allpara <- c(list(Class = "OverlappedRandomRegion",
#'             prevSteps = list(prevStep)),as.list(environment()),list(...))
#'         step <- do.call(new,allpara)
#'         invisible(step)
#'     }
#' )
#'
#' # add to graph
#' addEdges(edges = c("RandomRegionOnGenome","OverlappedRandomRegion"),
#'          argOrder = 1)
#' # begin to test pipeline
#' setGenome("hg19")
#' # generate test BED file
#' test_bed <- file.path(tempdir(),"test.bed")
#' library(rtracklayer)
#' export.bed(GRanges("chr7:1-127473000"),test_bed)
#'
#'
#' rd <- randomRegionOnGenome(10000)
#' overlap <- runOverlappedRandomRegion(rd, inputBed = test_bed)
#'
#' randombed <- getParam(rd,"outputBed")
#'
#' randombed
#'
#' overlap1 <-
#'     overlappedRandomRegion(inputBed = test_bed, randomBed = randombed)
#'
#' clearStepCache(overlap1)
#' overlap1 <-
#'     overlappedRandomRegion(inputBed = test_bed, randomBed = randombed)
#' clearStepCache(rd)
#' clearStepCache(overlap1)
#' rd <- randomRegionOnGenome(10000) %>%
#' runOverlappedRandomRegion(inputBed = test_bed)
#'
#' getStepName(rd)
#' getStepId(rd)
#' getDefName(rd)
#'
#' isReady(rd)

#' @export Step
Step <- setClass(Class = "Step",
                 slots = list(
                     argv = "list",
                     paramList = "list",
                     inputList = "list",
                     outputList = "list",
                     propList = "list",
                     reportVal = "list",
                     stepName = "character",
                     finish = "logical",
                     timeStampStart="POSIXct",
                     timeStampEnd="POSIXct",
                     maxThreads = "integer",
                     id = "integer",
                     groupName = "character",
                     loaded = "logical"
                 ),
                 prototype = c(argv = list(),
                               paramList = list(),
                               inputList = list(),
                               outputList = list(),
                               propList = list(),
                               reportVal = list(),
                               stepName = "Step",
                               finish = FALSE,
                               timeStampStart=Sys.time(),
                               timeStampEnd=Sys.time(),
                               maxThreads = 1L,
                               id = 0L,
                               groupName = character(),
                               loaded = FALSE)
)
setMethod(f = "initialize",
          signature = "Step",
          definition = function(.Object,prevSteps = list(),
                                groupName = NULL, ...){



              argv <- c(as.list(environment()),list(...))

              argv[["prevSteps"]] <- NULL


              stopifnot(is(prevSteps,"list"))
              if(length(prevSteps)>0){
                  objs<-unlist(prevSteps)
                  # for(obj in objs){
                  #     if(is.null(obj)){
                  #         next
                  #     }
                  #     stopifnot(inherits(obj,"Step"))
                  # }
                  lapply(objs, function(obj){
                      if(is.null(obj)){
                          return()
                      }
                      stopifnot(inherits(obj,"Step"))
                  })
              }

              stepName <- as.character(class(.Object))

              .Object@stepName <- stepName



              argvother <- argv[startsWith(names(argv),
                                           paste0(getDefName(.Object), "."))]
              # for(a in names(argvother)){
              #     a0 <- substring(a,1 + nchar(paste0(getDefName(.Object),".")))
              #     if(sum(names(argv)==a0)>0){
              #         argv[[a0]] <- argvother[[a]]
              #     }else{
              #         stop(paste0(a," is not parameter of Step ", stepName))
              #     }
              # }
              rs <- lapply(names(argvother), function(a){
                  a0 <- substring(a,1 + nchar(paste0(getDefName(.Object),".")))
                  if(sum(names(argv)==a0)>0){
                      return(argvother[[a]])
                  }else{
                      stop(paste0(a," is not parameter of Step ", stepName))
                  }
              })
              names(rs) <- names(argvother)
              sel <- setdiff(names(argv),names(argvother))
              argv <- c(argv[sel],rs)
              .Object@argv <- argv


              argSize <- length(prevSteps)


              if(argSize>0){
                  # for(i in 1:argSize){
                  #     if(!is.null(prevSteps[[i]]) && !isReady(prevSteps[[i]])){
                  #         stop(paste(getStepName(prevSteps[[i]]),
                  #                    "is not ready"))
                  #     }
                  #     # if(!checkRelation(getStepName(prevSteps[[i]]),
                  #     #getStepName(.Object),i)){
                  #     #     stop(paste(getStepName(prevSteps[[i]]),
                  #     #            "is not valid input"))
                  #     # }
                  #     if(!is.null(prevSteps[[i]])){
                  #         .Object@propList <- c(.Object@propList,
                  #                               prevSteps[[i]]@propList)
                  #         .Object@groupName <- c(.Object@groupName,
                  #                                prevSteps[[i]]@groupName)
                  #     }
                  # }
                  prop <- lapply(seq_len(argSize), function(i){
                      if(!is.null(prevSteps[[i]]) && !isReady(prevSteps[[i]])){
                          stop(paste(getStepName(prevSteps[[i]]),
                                     "is not ready"))
                      }
                      # if(!checkRelation(getStepName(prevSteps[[i]]),
                      #getStepName(.Object),i)){
                      #     stop(paste(getStepName(prevSteps[[i]]),
                      #            "is not valid input"))
                      # }
                      if(!is.null(prevSteps[[i]])){
                            return(prevSteps[[i]]@propList)
                      }
                  })
                  .Object@propList <- c(.Object@propList,as.list(unlist(prop)))

                  gpn <- lapply(seq_len(argSize), function(i){
                      if(!is.null(prevSteps[[i]]) && !isReady(prevSteps[[i]])){
                          stop(paste(getStepName(prevSteps[[i]]),
                                     "is not ready"))
                      }
                      # if(!checkRelation(getStepName(prevSteps[[i]]),
                      #getStepName(.Object),i)){
                      #     stop(paste(getStepName(prevSteps[[i]]),
                      #            "is not valid input"))
                      # }
                      if(!is.null(prevSteps[[i]])){
                           return(prevSteps[[i]]@groupName)
                      }
                  })
                  .Object@groupName <- c(.Object@groupName, unlist(gpn))
                  .Object@groupName <- sort(unique(.Object@groupName))
              }

              if(!is.null(groupName)){
                  stopifnot(!is.character(groupName))
                  .Object@groupName <- sort(unique(groupName))
              }

              if(is.null(groupName) && length(.Object@groupName)==0){
                  .Object@groupName <- "pipe"
              }






              nameObjList <- getOption("pipeFrameConfig.nameObjList")
              if(is.null(nameObjList)){
                  nameObjList <- list()
              }
              if(!is.null(nameObjList[[getDefName(.Object)]])){
                  .Object@id <- nameObjList[[getDefName(.Object)]]@id
              }else{
                  count <- getOption("pipeFrameConfig.count")
                  .Object@id <- count
              }
              options(pipeFrameConfig.allowChangeJobDir = FALSE)

              prevSteps <- list()
              # for(i in 1:10){
              #     s <- getPrevSteps(stepName = getStepName(.Object),i)
              #     if(is.null(s)){
              #         break
              #     }
              #     tt <- nameObjList[[
              #         paste0(s,"_",paste0(.Object@groupName,collapse = "_"))]]
              #     if(is.null(tt)){
              #         stop(paste("Step", s, " is required for", stepName,
              #                    "please calculate Step",s,"first"))
              #     }else{
              #         prevSteps<-c(prevSteps,list(tt))
              #     }
              # }
              prevSteps <- lapply(seq_len(10), function(i){
                  s <- getPrevSteps(stepName = getStepName(.Object),i)
                  if(is.null(s)){
                      return()
                  }
                  tt <- nameObjList[[
                      paste0(s,"_",paste0(.Object@groupName,collapse = "_"))]]
                  if(is.null(tt)){
                      stop(paste("Step", s, " is required for", stepName,
                                 "please calculate Step",s,"first"))
                  }else{
                      return(list(tt))
                  }
              })
              prevSteps <- as.list(unlist(prevSteps))




              if(!dir.exists(getStepWorkDir(.Object))){
                  dir.create(getStepWorkDir(.Object))
              }

              argv <- c(list(.Object = .Object,prevSteps = prevSteps),argv)
              obj_return_from_init <- do.call(init,argv)
              stopifnot(is(obj_return_from_init,getStepName(.Object)))
              .Object <- obj_return_from_init
              paramValidation(.Object)
              obj_return_from_porcessing<-process(.Object)
              stopifnot(is(obj_return_from_porcessing,getStepName(.Object)))
              .Object <- obj_return_from_porcessing

              if(is.null(nameObjList[[getDefName(.Object)]])){
                  count <- getOption("pipeFrameConfig.count")
                  options(pipeFrameConfig.count = count+1L)
              }
              nameObjList[[getDefName(.Object)]] <- .Object
              options(pipeFrameConfig.nameObjList = nameObjList)
              .Object
          })


setGeneric(name = "init",
           def = function(.Object,prevSteps = list(),...){
               standardGeneric("init")
           })


#' @return \item{init}{(For package developer only)
#' A Step child class object with initialized input,
#' output and other parameters}
#' @rdname Step-class
#' @aliases init
#' @export
setMethod(f = "init",
          signature = "Step",
          definition = function(.Object,prevSteps = list(),...){
             stop("`init` function need to be implemented for inherit classes")
          })



setGeneric(name = "process",
           def = function(.Object,...){
               standardGeneric("process")
           })


setMethod(f = "process",
          signature = "Step",
          definition = function(.Object,...){
              msgBoxBegin()
              if(checkMD5Cache(.Object)){
                  writeLog(.Object,paste0("The step:`",.Object@stepName,
                                          "` was finished. Nothing to do."))
                  writeLog(.Object,
                           paste0("If you need to redo,",
                                  "please call 'clearStepCache(YourObject)'"))
                  load(getParamMD5Path(.Object))
                  .Object <- pipeFrameObj
                  .Object@loaded <- TRUE
              }else{
                  writeLog(.Object,as.character(Sys.time()))
                  writeLog(.Object,paste0("start processing data: ",
                                          .Object@stepName))
                  .Object@timeStampStart<-Sys.time()
                  .Object <- processing(.Object)
                  .Object@timeStampEnd<-Sys.time()
                  .Object@reportVal$timeStampStart <-
                      .Object@timeStampStart
                  .Object@reportVal$timeStampEnd <-
                      .Object@timeStampEnd
                  .Object <- setFinish(.Object)
                  pipeFrameObj <- .Object
                  save(pipeFrameObj, file = getParamMD5Path(.Object))
              }
              msgBoxDone()
              .Object
          })



setGeneric(name = "getStepName",
           def = function(.Object,...){
               standardGeneric("getStepName")
           })

#' @return \item{getStepName}{get Step object Character name}
#' @rdname Step-class
#' @aliases getStepName
#' @export
setMethod(f = "getStepName",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@stepName)
          })




setGeneric(name = "getDefName",
           def = function(.Object,...){
               standardGeneric("getDefName")
           })

#' @return \item{getDefName}{get Step object Character name}
#' @rdname Step-class
#' @aliases getDefName
#' @export
setMethod(f = "getDefName",
          signature = "Step",
          definition = function(.Object,...){
              return(paste0(.Object@stepName,"_",paste0(.Object@groupName,
                                                        collapse = "_")))
          })

setGeneric(name = "setInput",
           def = function(.Object, item, value)
               standardGeneric("setInput")
           )

#' @rdname Step-class
#' @return \item{setInput}{Updated Step object after setting input directory}
#' @aliases  setInput
#' @export
setMethod(f = "setInput",
          signature = "Step",
          definition = function(.Object, item, value){
              if(item %in% c(names(.Object@outputList),names(.Object@paramList))){
                  stop(paste("item `",item, "` is an output or other parameter"))
              }
              .Object@inputList[[item]] <- value
              .Object
          })


setGeneric(name = "setOutput",
           def = function(.Object, item, value)
               standardGeneric("setOutput")
)

#' @rdname Step-class
#' @return \item{setOutput}{Updated Step object after setting output directory}
#' @aliases  setOutput
#' @export
setMethod(f = "setOutput",
          signature = "Step",
          definition = function(.Object, item, value){
              if(item %in% c(names(.Object@inputList),names(.Object@paramList))){
                  stop(paste("item `",item, "` is an input or other parameter"))
              }
              .Object@outputList[[item]] <- value
              .Object
          })



setGeneric(name = "setParam",
           def = function(.Object, item, value)
               standardGeneric("setParam")
)

#' @rdname Step-class
#' @return \item{setParam}{Updated Step object after setting parameters
#' excluded input and output directory}
#' @aliases  setParam
#' @export
setMethod(f = "setParam",
          signature = "Step",
          definition = function(.Object, item, value){
              if(item %in% c(names(.Object@inputList),names(.Object@outputList))){
                  stop(paste("item `",item, "` is an input or output"))
              }
              .Object@paramList[[item]] <- value
              .Object
          })


setGeneric(name = "getParam",
           def = function(.Object,item,...){
               standardGeneric("getParam")
           })

#' @rdname Step-class
#' @return \item{getParam}{Get parameter value set by process function.
#' See \code{getParamItems} to obtain valid items for query.}
#' @aliases  getParam
#' @export
setMethod(f = "getParam",
          signature = "Step",
          definition = function(.Object,item,
                                type = c("input","output","other"),...){
              type <- unique(type)
              # for(t in type){
              #     t1 <- match.arg(t,c("input","output","other"))
              #     if(t1 == "input"){
              #         if(!is.null(.Object@inputList[[item]])){
              #             return(.Object@inputList[[item]])
              #         }
              #     }else if(t1 == "output"){
              #         if(!is.null(.Object@outputList[[item]])){
              #             return(.Object@outputList[[item]])
              #         }
              #     }else{
              #         if(!is.null(.Object@paramList[[item]])){
              #             return(.Object@paramList[[item]])
              #         }
              #     }
              # }

              lapply(type, function(t){
                  t1 <- match.arg(t,c("input","output","other"))
              })
              if("input" %in% type){
                  if(!is.null(.Object@inputList[[item]])){
                      return(.Object@inputList[[item]])
                  }
              }
              if("output" %in% type){
                  if(!is.null(.Object@outputList[[item]])){
                      return(.Object@outputList[[item]])
                  }
              }
              if("other" %in% type){
                  if(!is.null(.Object@paramList[[item]])){
                      return(.Object@paramList[[item]])
                  }
              }
              return(NULL)
          })

setGeneric(name = "getParamItems",
           def = function(.Object, type = c("input","output","other"),...){
               standardGeneric("getParamItems")
           })

#' @rdname Step-class
#' @return \item{getParamItems}{Get parameter name list}
#' @aliases  getParamItems
#' @export
setMethod(f = "getParamItems",
          signature = "Step",
          definition = function(.Object, type = c("input","output","other"),
                                ...){
              type <- unique(type)
              allitem <- c()
              # for(t in type){
              #     t1 <- match.arg(t,c("input","output","other"))
              #     if(t1 == "input"){
              #         allitem <- c(allitem,names(.Object@inputList))
              #     }else if(t1 == "output"){
              #         allitem <- c(allitem,names(.Object@outputList))
              #     }else{
              #         allitem <- c(allitem,names(.Object@paramList))
              #     }
              # }
              allitem <- c()
              lapply(type, function(t){
                  t1 <- match.arg(t,c("input","output","other"))
              })
              if("input" %in% type){
                  allitem <-c(allitem, names(.Object@inputList))
              }
              if("output" %in% type){
                  allitem <-c(allitem,names(.Object@outputList))
              }
              if("other" %in% type){
                  allitem <-c(allitem,names(.Object@paramList))
              }
              return(allitem)
          })



setGeneric(name = "isReady",
           def = function(.Object,...){
               standardGeneric("isReady")
           })

#' @rdname Step-class
#' @return \item{isReady}{Is the process ready for downstream process}
#' @aliases  isReady
#' @export
setMethod(f = "isReady",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@finish)
          })


setGeneric(name = "clearStepCache",
           def = function(.Object,...){
               standardGeneric("clearStepCache")
           })

#' @rdname Step-class
#' @return \item{clearStepCache}{Clear cache of Step object}
#' @aliases  clearStepCache
#' @export
setMethod(f = "clearStepCache",
          signature = "Step",
          definition = function(.Object,...){
              if(!unlink(getParamMD5Path(.Object))){
                  message("Chache has been cleared")
              }else{
                  message("Chache does not exist. Nothing has been done.")
              }
              outItems <-getParamItems(.Object,type="output")
              # for(item in outItems){
              #     unlink(normalizePath(unlist(getParam(.Object,item))),
              #            recursive = TRUE)
              # }
              lapply(outItems, function(item){
                  if(sum(file.exists(unlist(getParam(.Object,item))))>0){
                        unlink(normalizePath(unlist(getParam(.Object,item))),
                         recursive = TRUE)
                  }
              })
              .Object@finish<-FALSE
              .Object
          })



setGeneric(name = "getReportVal",
           def = function(.Object,item,...){
               standardGeneric("getReportVal")
           })

#' @rdname Step-class
#' @return \item{getReportVal}{Get report value of item.
#' See \code{getReportItems} to obtain valid items for query.}
#' @aliases   getReportVal
#' @export
setMethod(f = "getReportVal",
          signature = "Step",
          definition = function(.Object,item,...){
              if(.Object@finish){
                  if(sum(item == getReportItemsImp(.Object))>0){
                      return(getReportValImp(.Object,item))
                  }else{
                      stop(paste0(item," is not an item of report value."))
                  }
              }else{
                  stop("Unfinished process is not available for report value.")
              }
          })


setGeneric(name = "getReportItems",
           def = function(.Object,...){
               standardGeneric("getReportItems")
           })

#' @rdname Step-class
#' @return \item{getReportItems}{Get all items that can be reported}
#' @aliases getReportItems
#' @export
setMethod(f = "getReportItems",
          signature = "Step",
          definition = function(.Object,...){
              if(.Object@finish){
                  return(getReportItemsImp(.Object))
              }else{
                  stop("Unfinished process is not available for report items.")
              }
          })
setGeneric(name = "getAutoPath",
           def = function(.Object,originPath,regexSuffixName,suffix,...){
               standardGeneric("getAutoPath")
           })

#' @return \item{getAutoPath}{(For package developer)
#' Developer can use this method to generate new file name
#' based on exist input file name}
#' @rdname Step-class
#' @aliases getAutoPath
#' @export
setMethod(f = "getAutoPath",
          signature = "Step",
          definition = function(.Object,originPath,regexSuffixName,suffix,...){
              stopifnot(is.character(originPath))
              prefix<-getBasenamePrefix(originPath,regexSuffixName)
              return(file.path(getStepWorkDir(.Object),
                               paste0(prefix,".",suffix)))
          })
setGeneric(name = "paramValidation",
           def = function(.Object,...){
               standardGeneric("paramValidation")
           })
setMethod(f = "paramValidation",
          signature = "Step",
          definition = function(.Object,...){
              if(!checkMD5Cache(.Object)){
                  checkAllPath(.Object)
              }
              checkRequireParam(.Object);
          })


setGeneric(name = "checkRequireParam",
           def = function(.Object,...){
               standardGeneric("checkRequireParam")
           })

#' @return \item{checkRequireParam}{(For package developer)
#' Check required inputs or parameters are filled.}
#' @rdname Step-class
#' @aliases checkRequireParam
#' @export
setMethod(f = "checkRequireParam",
          signature = "Step",
          definition = function(.Object,...){
              # override this function if necessary
              return(TRUE)
          })



setGeneric(name = "checkAllPath",
           def = function(.Object,...){
               standardGeneric("checkAllPath")
           })

#' @return \item{checkRequireParam}{(For package developer)
#'  Check required inputs are filled.}
#' @rdname Step-class
#' @aliases checkAllPath
#' @export
setMethod(f = "checkAllPath",
          signature = "Step",
          definition = function(.Object,...){
              items <- getParamItems(.Object, type="input")
              # for(items in items){
              #     paths<-.Object@inputList[[items]]
              #     if(!is.null(paths)){
              #         for(path in paths){
              #             if(!file.exists(path)){
              #                 stop(paste0("input ",
              #                             items,
              #                             "'s directory '",
              #                             path,"' does not exist."))
              #             }
              #         }
              #     }
              # }
              lapply(items, function(item){
                  paths<-.Object@inputList[[item]]
                  if(!is.null(paths)){
                      # for(path in paths){
                      #     if(!file.exists(path)){
                      #         stop(paste0("input ",
                      #                     item,
                      #                     "'s directory '",
                      #                     path,"' does not exist."))
                      #     }
                      # }
                      lapply(paths, function(path){
                          if(!file.exists(path)){
                              stop(paste0("input ",
                                          item,
                                          "'s directory '",
                                          path,"' does not exist."))
                          }
                      })
                  }
              })
              items <- getParamItems(.Object, type="output")
              # for(item in items){
              #     paths<-.Object@inputList[[items]]
              #     if(!is.null(paths)){
              #         for(path in paths){
              #             if(!dir.exists(path)){
              #                 file.create(path)
              #                 unlink(path)
              #             }
              #         }
              #     }
              # }
              lapply(items, function(item){
                  paths<-.Object@inputList[[item]]
                  if(!is.null(paths)){
                      # for(path in paths){
                      #     if(!dir.exists(path)){
                      #         file.create(path)
                      #         unlink(path)
                      #     }
                      # }
                      lapply(paths, function(path){
                          if(!dir.exists(path)){
                              file.create(path)
                              unlink(path)
                          }
                      })
                  }
              })
          })

setGeneric(name = "getParamMD5Path",
           def = function(.Object,...){
               standardGeneric("getParamMD5Path")
           })
#' @return \item{getParamMD5Path}{The Step object storage directory}
#' @rdname Step-class
#' @aliases getParamMD5Path
#' @export
setMethod(f = "getParamMD5Path",
          signature = "Step",
          definition = function(.Object,...){
              paramstr <- c(getStepName(.Object))
              itNames <- getParamItems(.Object,type="other")
              # for(n in sort(itNames)){
              #     paramstr<-c(paramstr,n)
              #     paramstr<-c(paramstr,getParam(.Object,n,type="other"))
              # }
              rs <- lapply(sort(itNames), function(n){
                  return(c(n,getParam(.Object,n,type="other")))
              })
              paramstr <- c(paramstr,unlist(rs))
              ioNames <- getParamItems(.Object,type=c("input","output"))
              # for(n in sort(ioNames)){
              #     paramstr<-c(paramstr,n)
              #     paths <- getParam(.Object,n,type = c("input","output"))
              #     if(!is.character(paths) && !is.list(paths)){
              #         paramstr <- c(paramstr,paths)
              #         next
              #     }
              #     paths <- sort(unlist(paths))
              #     paths1 <- c()
              #     breakflag <- FALSE
              #     for(path in paths){
              #         if(dir.exists(path)){
              #             paths1 <- c(paths1, sort(dir(path,recursive = TRUE)))
              #         }else if(file.exists(path)){
              #             paths1 <- c(paths1, path)
              #         }else{
              #             paramstr <- c(paramstr,runif(1))
              #             breakflag <- TRUE
              #             break;
              #         }
              #     }
              #     if(breakflag){
              #         break
              #     }
              #     paths <- paths1
              #     paths <- paths[grep("pipeFrame.obj",paths,invert = TRUE)]
              #     checkpaths <- c()
              #     for(path in paths){
              #         p <- normalizePath(path)
              #         checkpaths <- c(checkpaths,p)
              #         if(startsWith(p,getJobDir())){
              #             p <- substring(p,2+nchar(getJobDir()))
              #         }
              #         paramstr <- c(paramstr,p)
              #     }
              #     for(p in checkpaths){
              #         filesize <- file.info(p)$size
              #         paramstr <- c(paramstr,filesize)
              #     }
              # }
              paramstr0 <- lapply(sort(ioNames), function(n){
                  paramstr0<- n
                  paths <- getParam(.Object,n,type = c("input","output"))
                  if(!is.character(paths) && !is.list(paths)){
                      paramstr0 <- c(paramstr0, paths)
                      return(paramstr0)
                  }
                  paths <- sort(unlist(paths))
                  paths1 <- c()
                  breakflag <- FALSE
                  # for(path in paths){
                  #     if(dir.exists(path)){
                  #         paths1 <- c(paths1, sort(dir(path,recursive = TRUE)))
                  #     }else if(file.exists(path)){
                  #         paths1 <- c(paths1, path)
                  #     }else{
                  #         paramstr <- c(paramstr,runif(1))
                  #         breakflag <- TRUE
                  #         break;
                  #     }
                  # }
                  flag <- lapply(paths,function(path){
                      if(dir.exists(path)){
                          return(FALSE)
                      }else if(file.exists(path)){
                          return(FALSE)
                      }else{
                          return(TRUE)
                      }
                  })
                  if(sum(unlist(flag))>0){
                      return(runif(1))
                  }
                  paths1 <- lapply(paths,function(path){
                      if(dir.exists(path)){
                          return(sort(dir(path,recursive = TRUE)))
                      }else if(file.exists(path)){
                          return(path)
                      }else{
                          return(runif(1))
                      }
                  })
                  paths1 <- unlist(paths1)

                  paths <- paths1
                  paths <- paths[grep("pipeFrame.obj",paths,invert = TRUE)]
                  checkpaths <- c()
                  # for(path in paths){
                  #     p <- normalizePath(path)
                  #     checkpaths <- c(checkpaths,p)
                  #     if(startsWith(p,getJobDir())){
                  #         p <- substring(p,2+nchar(getJobDir()))
                  #     }
                  #     paramstr <- c(paramstr,p)
                  # }
                  ps <- lapply(paths, function(path){
                      p <- normalizePath(path)
                      checkpaths <- c(checkpaths,p)
                      if(startsWith(p,getJobDir())){
                          p <- substring(p,2+nchar(getJobDir()))
                      }
                      return(p)
                  })
                  paramstr0 <- c(paramstr0,unlist(ps))
                  # for(p in checkpaths){
                  #     filesize <- file.info(p)$size
                  #     paramstr <- c(paramstr,filesize)
                  # }
                  fs <- lapply(checkpaths, function(p){
                      file.info(p)$size
                  })
                  paramstr0 <- c(paramstr0, unlist(fs))
                  return(paramstr0)
              })
              paramstr <- c(paramstr,paramstr0)
              md5code<-substr(digest(object = paramstr,algo = "md5"),1,8)
              md5filepath<-file.path(getStepWorkDir(.Object),
                                     paste("pipeFrame.obj",md5code,
                                          "RData",sep = "."))
              return(md5filepath)
          })
setGeneric(name = "setFinish",
           def = function(.Object,...){
               standardGeneric("setFinish")
           })
setMethod(f = "setFinish",
          signature = "Step",
          definition = function(.Object,...){
              .Object@finish<-TRUE
              writeLog(.Object,as.character(Sys.time()))
              writeLog(.Object,"processing finished")
              .Object
          })
setGeneric(name = "checkMD5Cache",
           def = function(.Object,...){
               standardGeneric("checkMD5Cache")
           })
setMethod(f = "checkMD5Cache",
          signature = "Step",
          definition = function(.Object,...){
              if(file.exists(getParamMD5Path(.Object))){
                  return(TRUE)
              }else{
                  return(FALSE)
              }
          })

setGeneric(name = "getStepWorkDir",
           def = function(.Object, filename = NULL, ...){
               standardGeneric("getStepWorkDir")
           })
#' @return \item{getStepWorkDir}{Get the step work directory of this object}
#' @rdname Step-class
#' @aliases getStepWorkDir
#' @export
setMethod(f = "getStepWorkDir",
          signature = "Step",
          definition = function(.Object, filename = NULL, ...){
              if(is.null(filename)){
                  return(file.path(getJobDir(),
                                   paste0("Step_",
                                          sprintf("%02d",
                                                  getStepId(.Object)),
                                          "_",getDefName(.Object))))
              }else{
                  return(file.path(getJobDir(),
                                   paste0("Step_",
                                          sprintf("%02d",getStepId(.Object)),
                                          "_",getDefName(.Object)),filename))
              }

          })

setGeneric(name = "getStepId",
           def = function(.Object,...){
               standardGeneric("getStepId")
           })

#' @return \item{getStepId}{Get the step ID}
#' @rdname Step-class
#' @aliases getStepId
#' @export
setMethod(f = "getStepId",
          signature = "Step",
          definition = function(.Object,...){
              return(.Object@id)
          })



setGeneric(name = "writeLog",
           def = function(.Object,msg,...,isWarnning=FALSE,
                          appendLog=TRUE,showMsg=TRUE){
               standardGeneric("writeLog")
           })
#' @return \item{writeLog}{(For package developer) write log.}
#' @rdname Step-class
#' @aliases writeLog
#' @export
setMethod(f = "writeLog",
          signature = "Step",
          definition = function(.Object,msg,...,isWarnning=FALSE,
                                appendLog=TRUE,showMsg=TRUE){
              if(isWarnning){
                  warning(msg)
                  msg<-paste0("Warning:",msg)
              }else if(showMsg){
                  message(msg)
              }
              write.table(
                  msg,file.path(getStepWorkDir(.Object),
                                "pipeFrame.obj.log"),quote = FALSE,
                  row.names = FALSE,col.names = FALSE,append = appendLog)
              .Object
          })

#' @return \item{processing}{(For package developer) Run pipeline step}
#' @rdname Step-class
#' @aliases processing
#' @export
setGeneric(name = "processing",
           def = function(.Object,...){
               standardGeneric("processing")
           })





setGeneric(name = "getReportValImp",
           def = function(.Object,item,...){
               standardGeneric("getReportValImp")
           })


#' @return \item{getReportValImp}{(For package developer) get Report Value}
#' @rdname Step-class
#' @aliases getReportValImp
#' @export
setMethod(f = "getReportValImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(.Object@reportVal[[item]])
          })


setGeneric(name = "getReportItemsImp",
           def = function(.Object,item,...){
               standardGeneric("getReportItemsImp")
           })

#' @return \item{getReportItemsImp}{(For package developer) getReportItemsImp}
#' @rdname Step-class
#' @aliases getReportItemsImp
#' @export
setMethod(f = "getReportItemsImp",
          signature = "Step",
          definition = function(.Object,item,...){
              return(names(.Object@reportVal))
          })




